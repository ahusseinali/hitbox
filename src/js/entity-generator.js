/**
 * Manages generating random entities.
 */
class EntityGenerator {
	constructor(config) {
		this.DIRECTIONS = [
			{x:1 , y: 1},
			{x: -1, y: 1},
			{x: -1, y: 1},
			{x: -1, y: -1},
			{x: -1, y: -1},
			{x: 1, y: -1},
			{x: 1, y: -1},
			{x: 1, y: 1}
		];
		this.config_ = config;
	}

	/**
	 * Generates an enemy entity with random dimensions, position, speed and color.
	 */
	generateEnemy() {
		let minWidth = this.config_.canvasWidth * this.config_.enemyMinWidthRatio;
		let maxWidth = this.config_.canvasWidth * this.config_.enemyMaxWidthRatio;
		let minHeight = this.config_.canvasHeight * this.config_.enemyMinHeightRatio;
		let maxHeight = this.config_.canvasHeight * this.config_.enemyMaxHeightRatio;
		let dimensions = {
			x: Math.floor(Math.random() * maxWidth) + minWidth,
			y: Math.floor(Math.random() * maxHeight) + minHeight,
		};
		let index = Math.floor(Math.random() * this.DIRECTIONS.length);
		let position = this.generateRandomPosition_(dimensions, index);
		let speed = this.generateRandomSpeed_(index);
		let color = this.generateRandomColor_();
		return new Enemy(position, dimensions, color, this.config_, speed);
	}

	/**
	 * Sets the center point of enemy at a random location.
	 * The method divides canvas into 8 regions.
	 *  ____ ____
	 * |\ 0 | 1 /|
	 * | \  |  / |
	 * |7 \ | / 2|
	 * |___\|/___|
	 * |   /|\   |
	 * |6 / | \ 3|
	 * | /5 |4 \ |
	 * |/___|___\| 
	 *
	 * It randomly selects one region to generate the center point of the entity at its edge. It then
	 * randomly selects the center point on that edge. Then the final position is generated by
	 * shifting the center point away from the canvas edge to be completely out of canvas bounds and
	 * returns the top left corner position.
	 * @returns {{x: number, y: number}} The new random position.
	 */
	generateRandomPosition_(dimensions, locationIndex) {
		let x = 0;
		let y = 0;
		let w = this.config_.canvasWidth;
		let h = this.config_.canvasHeight;
		switch(locationIndex) {
			case 0:
				x = Math.floor(Math.random() * w / 2);
				y = -1 * dimensions.y / 2 - 10;
				break;
			case 1:
				x = Math.floor(Math.random() * w / 2) + w / 2;
				y = -1 * dimensions.y / 2 - 10;
				break;
			case 2:
				x = dimensions.x / 2 + w + 10;
				y = Math.floor(Math.random() * h / 2);
				break;
			case 3:
				x = dimensions.x / 2 + w + 10;
				y = Math.floor(Math.random() * h / 2) + h / 2;
				break;
			case 4:
				x = Math.floor(Math.random() * w / 2) + w / 2;
				y = dimensions.y / 2 + h + 10;
				break;
			case 5:
				x = Math.floor(Math.random() * w / 2);
				y = dimensions.y / 2 + h + 10;
				break;
			case 6:
				x = -1 * dimensions.x / 2 - 10;
				y = Math.floor(Math.random() * h / 2) + h / 2;
				break;
			case 7:
				x = -1 * dimensions.x / 2 - 10;
				y = Math.floor(Math.random() * h / 2);
				break;
			default:
				break;
		}
		return {x: x, y: y};
	}

	/**
	 * Generates a random speed in the range of min and max speed
	 * configuration in both dimensions.
	 */
	generateRandomSpeed_(locationIndex) {
		let min = this.config_.minSpeed;
		let max = this.config_.maxSpeed;
		let directionRatio = this.DIRECTIONS[locationIndex];
		let xSpeed = Math.floor(Math.random() * (max - min)) + min;
		let ySpeed = Math.floor(Math.random() * (max - min)) + min;
		return {x: xSpeed * directionRatio.x, y: ySpeed * directionRatio.y};
	}

	/**
	 * Generates a random color. We need to make sure avoid generating super white colors.
	 */
	generateRandomColor_() {
		let r = Math.floor(Math.random() * 230);
		let g = Math.floor(Math.random() * 230);
		let b = Math.floor(Math.random() * 230);

		return 'rgba(' + r + ',' + g + ',' + b + ',1)';
	}
}
